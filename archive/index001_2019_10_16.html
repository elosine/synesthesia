<!DOCTYPE html>
<html lang="en" dir="ltr">

<head>
  <meta charset="utf-8">
  <title>Fidgets - Vertical Lines</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato">
</head>
<style>
  * {
    font-family: 'Lato';
  }

  #svgcanvas {
    background-color: black;
    position: absolute;
    top: 0px;
    left: 0px;
    /* height: calc(100% - 30px);
    width: calc(100% - 30px); */
    height: 100%;
    width: 100%;
    margin: 0;
    z-index: -1;
  }

  #newOscB {
  background-color: #4CAF50; /* Green */
  border: none;
  color: white;
  padding: 15px 32px;
  text-align: center;
  text-decoration: none;
  display: inline-block;
  font-size: 16px;
  margin: 4px 2px;
  cursor: pointer;
  width: 500;
}

</style>

<body onload='setup();'>
  <button id='onbutton'>
    <svg id="svgcanvas" xmlns="http://www.w3.org/2000/svg">
      <defs>
        <!-- Filter: neongreen -->
        <filter id="neongreen" filterUnits="userSpaceOnUse" x="-50%" y="-50%" width="200%" height="200%">
          <!-- blur the text at different levels-->
          <feGaussianBlur in="SourceGraphic" stdDeviation="5" result="blur5" />
          <feGaussianBlur in="SourceGraphic" stdDeviation="10" result="blur10" />
          <feGaussianBlur in="SourceGraphic" stdDeviation="20" result="blur20" />
          <feGaussianBlur in="SourceGraphic" stdDeviation="30" result="blur30" />
          <feGaussianBlur in="SourceGraphic" stdDeviation="50" result="blur50" />
          <feGaussianBlur in="SourceGraphic" stdDeviation="60" result="blur60" />
          <feGaussianBlur in="SourceGraphic" stdDeviation="70" result="blur70" />
          <!-- merge all the blurs except for the first one -->
          <feMerge result="blur-merged">
            <feMergeNode in="blur10" />
            <feMergeNode in="blur20" />
            <feMergeNode in="blur30" />
            <feMergeNode in="blur50" />
            <!-- <feMergeNode in="blur60" /> -->
            <!-- <feMergeNode in="blur70" /> -->
          </feMerge>
          <!-- recolour the merged blurs red-->
          <feColorMatrix result="limegreen-blur" in="blur-merged" type="matrix" values="
                               0.6 0 0 0 0
                               0 1 0 0 0
                               0 0 0 0 0
                               0 0 0 1 0" />
          <feMerge>
            <feMergeNode in="limegreen-blur" /> <!-- largest blurs coloured red -->
            <feMergeNode in="blur5" /> <!-- smallest blur left white -->
            <feMergeNode in="SourceGraphic" /> <!-- original white text -->
          </feMerge>
        </filter>

        <!-- Filter: neonyellow -->
        <filter id="neonyellow" filterUnits="userSpaceOnUse" x="-50%" y="-50%" width="200%" height="200%">
          <!-- blur the text at different levels-->
          <feGaussianBlur in="SourceGraphic" stdDeviation="5" result="blur5" />
          <feGaussianBlur in="SourceGraphic" stdDeviation="10" result="blur10" />
          <feGaussianBlur in="SourceGraphic" stdDeviation="20" result="blur20" />
          <feGaussianBlur in="SourceGraphic" stdDeviation="30" result="blur30" />
          <feGaussianBlur in="SourceGraphic" stdDeviation="50" result="blur50" />
          <feGaussianBlur in="SourceGraphic" stdDeviation="60" result="blur60" />
          <feGaussianBlur in="SourceGraphic" stdDeviation="70" result="blur70" />
          <!-- merge all the blurs except for the first one -->
          <feMerge result="blur-merged">
            <feMergeNode in="blur10" />
            <feMergeNode in="blur20" />
            <feMergeNode in="blur30" />
            <feMergeNode in="blur50" />
            <feMergeNode in="blur60" />
            <feMergeNode in="blur70" />
          </feMerge>
          <!-- recolour the merged blurs red-->
          <feColorMatrix result="coloredblur" in="blur-merged" type="matrix" values="
                                 0.95 0 0 0 0
                                 0 0.95 0 0 0
                                 0 0 0.08 0 0
                                 0 0 0 1 0" />
          <feMerge>
            <feMergeNode in="coloredblur" /> <!-- largest blurs coloured red -->
            <feMergeNode in="blur5" /> <!-- smallest blur left white -->
            <feMergeNode in="SourceGraphic" /> <!-- original white text -->
          </feMerge>
        </filter>

        <!-- Filter: neonblue -->
        <filter id="neonblue" filterUnits="userSpaceOnUse" x="-50%" y="-50%" width="200%" height="200%">
          <!-- blur the text at different levels-->
          <feGaussianBlur in="SourceGraphic" stdDeviation="5" result="blur5" />
          <feGaussianBlur in="SourceGraphic" stdDeviation="10" result="blur10" />
          <feGaussianBlur in="SourceGraphic" stdDeviation="20" result="blur20" />
          <feGaussianBlur in="SourceGraphic" stdDeviation="30" result="blur30" />
          <feGaussianBlur in="SourceGraphic" stdDeviation="50" result="blur50" />
          <feGaussianBlur in="SourceGraphic" stdDeviation="60" result="blur60" />
          <feGaussianBlur in="SourceGraphic" stdDeviation="70" result="blur70" />
          <!-- merge all the blurs except for the first one -->
          <feMerge result="blur-merged">
            <feMergeNode in="blur10" />
            <feMergeNode in="blur20" />
            <feMergeNode in="blur30" />
            <feMergeNode in="blur50" />
            <feMergeNode in="blur60" />
            <feMergeNode in="blur70" />
          </feMerge>
          <!-- recolour the merged blurs red-->
          <feColorMatrix result="coloredblur" in="blur-merged" type="matrix" values="
                                 0 0 0 0 0
                                 0 0.98 0 0 0
                                 0 0 1 0 0
                                 0 0 0 1 0" />
          <feMerge>
            <feMergeNode in="coloredblur" /> <!-- largest blurs coloured red -->
            <feMergeNode in="blur5" /> <!-- smallest blur left white -->
            <feMergeNode in="SourceGraphic" /> <!-- original white text -->
          </feMerge>
        </filter>
      </defs>
    </svg>
  </button>
  <button id='newOscB'></button>
</body>

<script>
  // GLOBAL VARIABLES ---------------------------------------------- //
  //TIMING & ANIMATION ENGINE //////////////////////////////
  var FRAMERATE = 60.0;
  var MSPERFRAME = 1000.0 / FRAMERATE;
  var SECPERFRAME = 1.0 / FRAMERATE;
  var PXPERSEC = 100.0;
  var PXPERMS = PXPERSEC / 1000.0;
  var PXPERFRAME = PXPERSEC / FRAMERATE;
  var framect = 0;
  var delta = 0.0;
  var lastFrameTimeMs = 0.0;
  var pieceClock = 0.0;
  var clockadj = 0.0;
  // SVG ///////////////////////////////////////////////////
  var svgcanvas = document.getElementById('svgcanvas');
  var svgNS = "http://www.w3.org/2000/svg";
  var canvasW = window.innerWidth;
  var canvasH = window.innerHeight;
  // LINES /////////////////////////////////////////////////
  var linesSet = [];
  var numLines = 2;
  var accelMin = 0.992;
  var accelMax = 1.008;
  // var maxSpd = 2.7;
  // var minSpd = 0.33333;
  var maxSpd = 3.3;
  var minSpd = 0.45;
  var spdChgGate = true;
  // AUDIO /////////////////////////////////////////////////
  var CENTERPITCHMIDIOG = [55, 62, 69, 76, 83];
  var CENTERPITCHMIDI = shuffle(CENTERPITCHMIDIOG);
  var CENTERPITCHFREQS = [];
  for (var i = 0; i < CENTERPITCHMIDI.length; i++) {
    var tempfreq = mtof(CENTERPITCHMIDI[i]);
    CENTERPITCHFREQS.push(tempfreq);
  }
  var pitchPoles = [];
  var pitchPolePitchIx = 0;
  var oscillators = [];
  var audioCtx;
  var gainNodes = [];
  var played = false;
  // SET UP ----------------------------------------------------------- //
  function setup() {
    // linesSet = mkLines(numLines);
    var startButton = document.getElementById("onbutton");
    startButton.addEventListener("click", play);
    window.addEventListener('resize', winResize, false);
  }
  //FUNCTION mkPitchPole ------------------------------------------------------ //
  function mkPitchPole() {
    // Make Gain Node ///////////////////////////////////
    var tempGainNode = audioCtx.createGain();
    tempGainNode.gain.setValueAtTime(0, audioCtx.currentTime);
    tempGainNode.connect(audioCtx.destination);
    // Make Oscillator ///////////////////////////////////
    var tempOsc = audioCtx.createOscillator();
    tempOsc.type = 'sine';
    var tempFreq = CENTERPITCHFREQS[pitchPolePitchIx];
    var tempMidi = CENTERPITCHMIDI[pitchPolePitchIx];
    tempOsc.frequency.setValueAtTime(tempFreq, audioCtx.currentTime);
    pitchPolePitchIx = (pitchPolePitchIx + 1) % CENTERPITCHFREQS.length;
    tempOsc.connect(tempGainNode);
    tempOsc.start();
    var tempLine = mkLine();
    var ppGr = [tempLine, tempGainNode, tempOsc, tempFreq, tempMidi];
    pitchPoles.push(ppGr);
  }
  //FUNCTION initAudio ------------------------------------------------------ //
  function initAudio() {
    audioCtx = new(window.AudioContext || window.webkitAudioContext)();
  }
  //FUNCTION play ------------------------------------------------------ //
  function play() {
    if (!played) {
      played = true;
      initAudio();
      mkPitchPole();
      envOn(pitchPoles[0][1].gain, 6, 0.2);
      mkOscillator();
      // envOn(oscillators[0][1].gain, 6, 0.2);
      //Make Buttons
      var newOscButton = document.getElementById("newOscB");
      newOscButton.addEventListener("click", mkOscillator);
      requestAnimationFrame(animationEngine);
    }
  }
  //FUNCTION mkOscillators ------------------------------------------------- //
  function mkOscillator() {
    var tempLine = mkLine();
    for (var i = 0; i < pitchPoles.length; i++) {
      // Make Gain Node ///////////////////////////////////
      var tempGainNode = audioCtx.createGain();
      tempGainNode.gain.setValueAtTime(0, audioCtx.currentTime);
      tempGainNode.connect(audioCtx.destination);
      // Make Oscillator ///////////////////////////////////
      var tempOsc = audioCtx.createOscillator();
      tempOsc.type = 'sine';
      tempOsc.frequency.setValueAtTime(440, audioCtx.currentTime);
      tempOsc.connect(tempGainNode);
      tempOsc.start();
      envOn(tempGainNode.gain, 6, 0.2);
      var oscGr = [tempLine, tempGainNode, tempOsc];
      oscillators.push(oscGr);
    }
  }
  // FUNCTION mkLines ------------------------------------------------- //
  function mkLine() {
    var templine = document.createElementNS(svgNS, 'line');
    templine.setAttributeNS(null, 'x1', 1);
    templine.setAttributeNS(null, 'x2', 1);
    templine.setAttributeNS(null, 'y1', 3);
    templine.setAttributeNS(null, 'y2', canvasH - 4);
    templine.setAttributeNS(null, 'stroke', 'rgb(255,255,255)');
    templine.setAttributeNS(null, 'stroke-width', 7);
    templine.setAttributeNS(null, 'filter', 'url(#neongreen)'); //make a switch
    templine.setAttributeNS(null, 'stroke-linecap', 'round');
    svgcanvas.appendChild(templine);
    var tempSpd = rrand(minSpd, maxSpd);
    var tempAccel = rrand(accelMin, accelMax);
    var frameOn = rrand(2, 10) * FRAMERATE;
    var frameOff = rrand(30, 60) * FRAMERATE;
    var tempLineGroup = [templine, tempSpd, tempAccel, 1, frameOn, frameOff];
    linesSet.push(tempLineGroup);
    return tempLineGroup;
  }
  // ANIMATION ENGINE ----------------------------------------------- //
  function animationEngine(timestamp) {
    delta += timestamp - lastFrameTimeMs;
    lastFrameTimeMs = timestamp;
    while (delta >= MSPERFRAME) {
      update(MSPERFRAME);
      delta -= MSPERFRAME;
    }
    requestAnimationFrame(animationEngine);
  }
  // UPDATE ---------------------------------------------------------- //
  function update(MSPERFRAME) {
    // Clocks ////////////////////////////////////////////////
    framect++;
    pieceClock += MSPERFRAME;
    pieceClock = pieceClock - clockadj;
    // Lines /////////////////////////////////////////////////
    for (var i = 0; i < linesSet.length; i++) {
      var oldX = parseFloat(linesSet[i][0].getAttributeNS(null, 'x1'));
      var oldSpd = linesSet[i][1];
      var oldAcc = linesSet[i][2];
      var oldDir = linesSet[i][3];
      var newSpd, newAcc, newDir, newX;
      var chgSpd;
      //// Boundry Detection ////////////////////////
      if (oldX > canvasW) {
        newDir = -1;
      } else if (oldX < 0) {
        newDir = 1;
      } else {
        newDir = oldDir;
      }
      //// Has Accel/Decel made the line too fast/slow?
      if (oldSpd > maxSpd || oldSpd < minSpd) {
        newAcc = scale((1 - norm(oldAcc, accelMin, accelMax)), 0.0, 1.0, accelMin, accelMax);
        if (oldSpd >= maxSpd) {
          chgSpd = maxSpd;
        } else if (oldSpd <= minSpd) {
          chgSpd = minSpd;
        }
        spdChgGate = false;
      } else {
        newAcc = oldAcc;
      }
      if (spdChgGate) {
        newSpd = oldSpd * newAcc;
      } else {
        newSpd = chgSpd * newAcc;
        spdChgGate = true;
      }
      newX = oldX + (newSpd * newDir);
      linesSet[i][0].setAttributeNS(null, "x1", newX);
      linesSet[i][0].setAttributeNS(null, "x2", newX);
      linesSet[i][1] = newSpd;
      linesSet[i][2] = newAcc;
      linesSet[i][3] = newDir;
    }
    // OSCILLATORS ////////////////////////////////////////////
    // var tempLineGroup = [templine, tempSpd, tempAccel, 1, frameOn, frameOff];
    // var ppGr = [[templine, tempSpd, tempAccel, 1, frameOn, frameOff], tempGainNode, tempOsc, tempFreq, tempMidi];
    // var oscGr = [[templine, tempSpd, tempAccel, 1, frameOn, frameOff], tempGainNode, tempOsc];
    for (var i = 0; i < pitchPoles.length; i++) {
      for (var j = 0; j < oscillators.length; j++) {
        var tPPx = parseFloat(pitchPoles[i][0][0].getAttributeNS(null, "x1"));
        var tOscX = parseFloat(oscillators[j][0][0].getAttributeNS(null, 'x1'));
        var tPPmidi = pitchPoles[i][4];
        var tDist = tPPx - tOscX;
        var tDiffMidi = scale(tDist, 0, canvasW, 0, 1);
        if (tPPx >= tOscX) {
          tNewFreq = mtof(tPPmidi - tDiffMidi);
          oscillators[j][2].frequency.setValueAtTime(tNewFreq, audioCtx.currentTime);
        } else if (tOscX >= tPPx) {
          tNewFreq = mtof(tPPmidi + tDiffMidi);
          oscillators[j][2].frequency.setValueAtTime(tNewFreq, audioCtx.currentTime);
        }
      }
    }

  }
  //FUNCTION envOn ------------------------------------------------------ //
  function envOn(vcaGain, attackTime, attackAmp) {
    var tblsz = 44100 * attackTime;
    var amptable = [];
    var attackAmpdb = linamp2db(attackAmp);
    var inc = Math.abs((-80 - attackAmpdb) / tblsz);
    for (var i = 0; i < tblsz; i++) {
      var tempamp = db2linamp(-80 + (inc * i));
      amptable.push(tempamp);
    }
    var now = audioCtx.currentTime;
    vcaGain.cancelScheduledValues(0);
    vcaGain.setValueAtTime(0, now);
    vcaGain.setValueCurveAtTime(amptable, now, attackTime);
    // vcaGain.linearRampToValueAtTime(attackAmp, attackTime);
  }
  //FUNCTION envOff ------------------------------------------------------ //
  function envOff(vcaGain, releaseTime) {
    var now = audioCtx.currentTime;
    vcaGain.cancelScheduledValues(0);
    vcaGain.setValueAtTime(vcaGain.value, now);
    vcaGain.linearRampToValueAtTime(0, now + releaseTime);
  }
  // FUNCTION: winResize ---------------------------------------------- //
  function winResize() {
    canvasW = window.innerWidth;
    canvasH = window.innerHeight;
    for (var i = 0; i < linesSet.length; i++) {
      linesSet[i][0].setAttributeNS(null, 'y2', canvasH - 4);
    }
  }
  // FUNCTION: mtof ---------------------------------------------- //
  function mtof(midinote) {
    var freq;
    freq = Math.pow(2, ((midinote - 69) / 12)) * 440;
    return freq;
  }
  // FUNCTION: ftom ---------------------------------------------- //
  function ftom(freq) {
    var midi;
    midi = (Math.log2((freq / 440)) * 12) + 69;
    return midi;
  }
  // FUNCTION: rrand ---------------------------------------------- //
  function rrand(min, max) {
    return Math.random() * (max - min) + min;
  }
  // FUNCTION: rrandInt ---------------------------------------------- //
  function rrandInt(min, max) {
    return Math.floor(Math.random() * (max - min) + min);
  }
  // FUNCTION: rrand ---------------------------------------------- //
  function choose(tempSet) {
    var randpick = rrandInt(0, tempSet.length);
    return tempSet[randpick];
  }
  // FUNCTION: scale ---------------------------------------------- //
  const scale = (num, in_min, in_max, out_min, out_max) => {
    return (num - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  }
  // FUNCTION: norm ---------------------------------------------- //
  const norm = (num, in_min, in_max) => {
    return (num - in_min) * (1.0 - 0.0) / (in_max - in_min);
  }
  // FUNCTION: shuffle ---------------------------------------------- //
  function shuffle(array) {
    for (let i = array.length - 1; i > 0; i--) {
      let j = Math.floor(Math.random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
  }
  // FUNCTION: db2linamp ---------------------------------------------- //
  function db2linamp(db) {
    var lamp = Math.pow(10, (db / 20));
    return lamp;
  }
  // FUNCTION: linamp2db ---------------------------------------------- //
  function linamp2db(linamp) {
    var db = 20 * Math.log(linamp);
    return db;
  }
</script>

</html>
