<!DOCTYPE html>
<html lang="en" dir="ltr">

<head>
  <meta charset="utf-8">
  <title>Fidgets - Vertical Lines</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato">
</head>
<style>
  * {
    font-family: 'Lato';
    margin: 0;
    padding: 0;
    border: none;
  }

  #svgcanvas {
    background-color: black;
    position: absolute;
    top: 0px;
    left: 0px;
    height: 100%;
    width: 100%;
    z-index: -1;
  }
</style>

<body onload='setup();'>
  <svg id="svgcanvas" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <!-- Filter: white -->
      <filter id="white" filterUnits="userSpaceOnUse" x="-50%" y="-50%" width="200%" height="200%">
        <!-- blur the text at different levels-->
        <feGaussianBlur in="SourceGraphic" stdDeviation="5" result="blur5" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="10" result="blur10" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="20" result="blur20" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="30" result="blur30" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="50" result="blur50" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="60" result="blur60" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="70" result="blur70" />
        <!-- merge all the blurs except for the first one -->
        <feMerge result="blur-merged">
          <feMergeNode in="blur10" />
          <feMergeNode in="blur20" />
          <feMergeNode in="blur30" />
          <feMergeNode in="blur50" />
          <!-- <feMergeNode in="blur60" /> -->
          <!-- <feMergeNode in="blur70" /> -->
        </feMerge>
        <!-- recolour the merged blurs -->
        <!-- (57, 255, 20) -->
        <feColorMatrix result="limegreen-blur" in="blur-merged" type="matrix" values="
                               1 0 0 0 0
                               0 1 0 0 0
                               0 0 1 0 0
                               0 0 0 1 0" />
        <feMerge>
          <feMergeNode in="limegreen-blur" /> <!-- largest blurs coloured red -->
          <feMergeNode in="blur5" /> <!-- smallest blur left white -->
          <feMergeNode in="SourceGraphic" /> <!-- original white text -->
        </feMerge>
      </filter>

      <!-- Filter: neongreen -->
      <filter id="neongreen" filterUnits="userSpaceOnUse" x="-50%" y="-50%" width="200%" height="200%">
        <!-- blur the text at different levels-->
        <feGaussianBlur in="SourceGraphic" stdDeviation="5" result="blur5" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="10" result="blur10" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="20" result="blur20" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="30" result="blur30" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="50" result="blur50" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="60" result="blur60" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="70" result="blur70" />
        <!-- merge all the blurs except for the first one -->
        <feMerge result="blur-merged">
          <feMergeNode in="blur10" />
          <feMergeNode in="blur20" />
          <feMergeNode in="blur30" />
          <feMergeNode in="blur50" />
          <!-- <feMergeNode in="blur60" /> -->
          <!-- <feMergeNode in="blur70" /> -->
        </feMerge>
        <!-- recolour the merged blurs red-->
        <!-- (57, 255, 20) -->
        <feColorMatrix result="limegreen-blur" in="blur-merged" type="matrix" values="
                               0.22 0 0 0 0
                               0 1 0 0 0
                               0 0 0.08 0 0
                               0 0 0 1 0" />
        <feMerge>
          <feMergeNode in="limegreen-blur" /> <!-- largest blurs coloured red -->
          <feMergeNode in="blur5" /> <!-- smallest blur left white -->
          <feMergeNode in="SourceGraphic" /> <!-- original white text -->
        </feMerge>
      </filter>

      <!-- Filter: neonyellow -->
      <filter id="neonyellow" filterUnits="userSpaceOnUse" x="-50%" y="-50%" width="200%" height="200%">
        <!-- blur the text at different levels-->
        <feGaussianBlur in="SourceGraphic" stdDeviation="5" result="blur5" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="10" result="blur10" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="20" result="blur20" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="30" result="blur30" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="50" result="blur50" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="60" result="blur60" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="70" result="blur70" />
        <!-- merge all the blurs except for the first one -->
        <feMerge result="blur-merged">
          <feMergeNode in="blur10" />
          <feMergeNode in="blur20" />
          <feMergeNode in="blur30" />
          <feMergeNode in="blur50" />
          <!-- <feMergeNode in="blur60" />
          <feMergeNode in="blur70" /> -->
        </feMerge>
        <!-- recolour the merged blurs -->
        <feColorMatrix result="coloredblur" in="blur-merged" type="matrix" values="
                                 1 0 0 0 0
                                 0 1 0 0 0
                                 0 0 0 0 0
                                 0 0 0 1 0" />
        <feMerge>
          <feMergeNode in="coloredblur" /> <!-- largest blurs coloured red -->
          <feMergeNode in="blur5" /> <!-- smallest blur left white -->
          <feMergeNode in="SourceGraphic" /> <!-- original white text -->
        </feMerge>
      </filter>

      <!-- Filter: neonorange -->
      <filter id="neonorange" filterUnits="userSpaceOnUse" x="-50%" y="-50%" width="200%" height="200%">
        <!-- blur the text at different levels-->
        <feGaussianBlur in="SourceGraphic" stdDeviation="5" result="blur5" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="10" result="blur10" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="20" result="blur20" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="30" result="blur30" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="50" result="blur50" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="60" result="blur60" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="70" result="blur70" />
        <!-- merge all the blurs except for the first one -->
        <feMerge result="blur-merged">
          <feMergeNode in="blur10" />
          <feMergeNode in="blur20" />
          <feMergeNode in="blur30" />
          <feMergeNode in="blur50" />
          <!-- <feMergeNode in="blur60" />
          <feMergeNode in="blur70" /> -->
        </feMerge>
        <!-- recolour the merged blurs red-->
        <!-- (255, 103, 0) -->
        <feColorMatrix result="coloredblur" in="blur-merged" type="matrix" values="
                                 1 0 0 0 0
                                 0 0.4 0 0 0
                                 0 0 0 0 0
                                 0 0 0 1 0" />
        <feMerge>
          <feMergeNode in="coloredblur" /> <!-- largest blurs coloured red -->
          <feMergeNode in="blur5" /> <!-- smallest blur left white -->
          <feMergeNode in="SourceGraphic" /> <!-- original white text -->
        </feMerge>
      </filter>

      <!-- Filter: red -->
      <filter id="red" filterUnits="userSpaceOnUse" x="-50%" y="-50%" width="200%" height="200%">
        <!-- blur the text at different levels-->
        <feGaussianBlur in="SourceGraphic" stdDeviation="5" result="blur5" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="10" result="blur10" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="20" result="blur20" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="30" result="blur30" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="50" result="blur50" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="60" result="blur60" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="70" result="blur70" />
        <!-- merge all the blurs except for the first one -->
        <feMerge result="blur-merged">
          <feMergeNode in="blur10" />
          <feMergeNode in="blur20" />
          <feMergeNode in="blur30" />
          <feMergeNode in="blur50" />
          <!-- <feMergeNode in="blur60" />
          <feMergeNode in="blur70" /> -->
        </feMerge>
        <!-- recolour the merged blurs red-->
        <feColorMatrix result="coloredblur" in="blur-merged" type="matrix" values="
                                 1 0 0 0 0
                                 0 0 0 0 0
                                 0 0 0 0 0
                                 0 0 0 1 0" />
        <feMerge>
          <feMergeNode in="coloredblur" /> <!-- largest blurs coloured red -->
          <feMergeNode in="blur5" /> <!-- smallest blur left white -->
          <feMergeNode in="SourceGraphic" /> <!-- original white text -->
        </feMerge>
      </filter>

      <!-- Filter: neonred -->
      <filter id="neonred" filterUnits="userSpaceOnUse" x="-50%" y="-50%" width="200%" height="200%">
        <!-- blur the text at different levels-->
        <feGaussianBlur in="SourceGraphic" stdDeviation="5" result="blur5" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="10" result="blur10" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="20" result="blur20" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="30" result="blur30" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="50" result="blur50" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="60" result="blur60" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="70" result="blur70" />
        <!-- merge all the blurs except for the first one -->
        <feMerge result="blur-merged">
          <feMergeNode in="blur10" />
          <feMergeNode in="blur20" />
          <feMergeNode in="blur30" />
          <feMergeNode in="blur50" />
          <!-- <feMergeNode in="blur60" />
          <feMergeNode in="blur70" /> -->
        </feMerge>
        <!-- recolour the merged blurs red-->
        <!-- (255, 7, 5) -->
        <feColorMatrix result="coloredblur" in="blur-merged" type="matrix" values="
                                 1 0 0 0 0
                                 0 0.03 0 0 0
                                 0 0 0.23 0 0
                                 0 0 0 1 0" />
        <feMerge>
          <feMergeNode in="coloredblur" /> <!-- largest blurs coloured red -->
          <feMergeNode in="blur5" /> <!-- smallest blur left white -->
          <feMergeNode in="SourceGraphic" /> <!-- original white text -->
        </feMerge>
      </filter>

      <!-- Filter: neonpink -->
      <filter id="neonpink" filterUnits="userSpaceOnUse" x="-50%" y="-50%" width="200%" height="200%">
        <!-- blur the text at different levels-->
        <feGaussianBlur in="SourceGraphic" stdDeviation="5" result="blur5" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="10" result="blur10" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="20" result="blur20" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="30" result="blur30" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="50" result="blur50" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="60" result="blur60" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="70" result="blur70" />
        <!-- merge all the blurs except for the first one -->
        <feMerge result="blur-merged">
          <feMergeNode in="blur10" />
          <feMergeNode in="blur20" />
          <feMergeNode in="blur30" />
          <feMergeNode in="blur50" />
          <!-- <feMergeNode in="blur60" />
          <feMergeNode in="blur70" /> -->
        </feMerge>
        <!-- recolour the merged blurs -->
        <!-- (255, 1, 154) -->
        <feColorMatrix result="coloredblur" in="blur-merged" type="matrix" values="
                                 1 0 0 0 0
                                 0 0 0 0 0
                                 0 0 0.6 0 0
                                 0 0 0 1 0" />
        <feMerge>
          <feMergeNode in="coloredblur" /> <!-- largest blurs coloured red -->
          <feMergeNode in="blur5" /> <!-- smallest blur left white -->
          <feMergeNode in="SourceGraphic" /> <!-- original white text -->
        </feMerge>
      </filter>

      <!-- Filter: neonturquoise -->
      <filter id="neonturquoise" filterUnits="userSpaceOnUse" x="-50%" y="-50%" width="200%" height="200%">
        <!-- blur the text at different levels-->
        <feGaussianBlur in="SourceGraphic" stdDeviation="5" result="blur5" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="10" result="blur10" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="20" result="blur20" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="30" result="blur30" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="50" result="blur50" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="60" result="blur60" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="70" result="blur70" />
        <!-- merge all the blurs except for the first one -->
        <feMerge result="blur-merged">
          <feMergeNode in="blur10" />
          <feMergeNode in="blur20" />
          <feMergeNode in="blur30" />
          <feMergeNode in="blur50" />
          <!-- <feMergeNode in="blur60" />
          <feMergeNode in="blur70" /> -->
        </feMerge>
        <!-- recolour the merged blurs -->
        <!-- (21, 244, 238) -->
        <feColorMatrix result="coloredblur" in="blur-merged" type="matrix" values="
                                 0.08 0 0 0 0
                                 0 0.96 0 0 0
                                 0 0 0.93 0 0
                                 0 0 0 1 0" />
        <feMerge>
          <feMergeNode in="coloredblur" /> <!-- largest blurs coloured red -->
          <feMergeNode in="blur5" /> <!-- smallest blur left white -->
          <feMergeNode in="SourceGraphic" /> <!-- original white text -->
        </feMerge>
      </filter>

      <!-- Filter: neonblue -->
      <filter id="neonblue" filterUnits="userSpaceOnUse" x="-50%" y="-50%" width="200%" height="200%">
        <!-- blur the text at different levels-->
        <feGaussianBlur in="SourceGraphic" stdDeviation="5" result="blur5" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="10" result="blur10" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="20" result="blur20" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="30" result="blur30" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="50" result="blur50" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="60" result="blur60" />
        <feGaussianBlur in="SourceGraphic" stdDeviation="70" result="blur70" />
        <!-- merge all the blurs except for the first one -->
        <feMerge result="blur-merged">
          <feMergeNode in="blur10" />
          <feMergeNode in="blur20" />
          <feMergeNode in="blur30" />
          <feMergeNode in="blur50" />
          <!-- <feMergeNode in="blur60" />
          <feMergeNode in="blur70" /> -->
        </feMerge>
        <!-- recolour the merged blurs -->
        <!-- (6, 107, 225) -->
        <feColorMatrix result="coloredblur" in="blur-merged" type="matrix" values="
                                 0.02 0 0 0 0
                                 0 0.42 0 0 0
                                 0 0 0.88 0 0
                                 0 0 0 1 0" />
        <feMerge>
          <feMergeNode in="coloredblur" /> <!-- largest blurs coloured red -->
          <feMergeNode in="blur5" /> <!-- smallest blur left white -->
          <feMergeNode in="SourceGraphic" /> <!-- original white text -->
        </feMerge>
      </filter>
    </defs>
  </svg>
</body>

<script>
  // GLOBAL VARIABLES ---------------------------------------------- //
  //TIMING & ANIMATION ENGINE //////////////////////////////
  var FRAMERATE = 60.0;
  var MSPERFRAME = 1000.0 / FRAMERATE;
  var SECPERFRAME = 1.0 / FRAMERATE;
  var PXPERSEC = 100.0;
  var PXPERMS = PXPERSEC / 1000.0;
  var PXPERFRAME = PXPERSEC / FRAMERATE;
  var framect = 0;
  var delta = 0.0;
  var lastFrameTimeMs = 0.0;
  var pieceClock = 0.0;
  var clockadj = 0.0;
  // COLORS ////////////////////////////////////////////////
  var neonred = 'rgb(255, 7, 5)',
    red = 'rgb(255,0,0)',
    neongreen = 'rgb(57, 255, 20)',
    neonyellow = 'rgb(255,255,0)',
    neonorange = 'rgb(255, 103, 0)',
    neonpink = 'rgb(255, 1, 154)',
    neonturquoise = 'rgb(21, 244, 238)',
    neonblue = 'rgb(6, 107, 225)',
    white = 'rgb(255,255,255)';
  // SVG ///////////////////////////////////////////////////
  var svgcanvas = document.getElementById('svgcanvas');
  var svgNS = "http://www.w3.org/2000/svg";
  var canvasW = window.innerWidth;
  var canvasH = window.innerHeight;
  // LINES /////////////////////////////////////////////////
  var ppLinesSet = [];
  var oscLinesSet = [];
  var numLines = 2;
  var accelMin = 0.992;
  var accelMax = 1.008;
  var maxSpd = 3.3;
  var minSpd = 0.45;
  var spdChgGate = true;
  // AUDIO /////////////////////////////////////////////////
  var CENTERPITCHMIDIOG = [41, 48, 55, 62, 69, 76, 83];
  var shufNumsOG = [];
  var CENTERPITCHMIDI = [];
  var filterClrs = [];
  var ppClrs = [];
  for (var i = 0; i < CENTERPITCHMIDIOG.length; i++) {
    shufNumsOG.push(i);
  }
  var shufNums = shuffle(shufNumsOG);
  for (var i = 0; i < shufNums.length; i++) {
    CENTERPITCHMIDI.push(CENTERPITCHMIDIOG[shufNums[i]]);
  }
  var filterClrsOG = ['url(#neongreen)', 'url(#neonred)', 'url(#neonblue)', 'url(#neonorange)',
    'url(#neonyellow)', 'url(#neonpink)', 'url(#neonturquoise)'
  ];
  var filterWhite = 'url(#white)';
  var ppClrsOG = [neongreen, neonred, neonblue, neonorange,
    neonyellow, neonpink, neonturquoise
  ];
  for (var i = 0; i < shufNums.length; i++) {
    filterClrs.push(filterClrsOG[shufNums[i]]);
    ppClrs.push(ppClrsOG[shufNums[i]]);
  }
  var CENTERPITCHFREQS = [];
  for (var i = 0; i < CENTERPITCHMIDI.length; i++) {
    var tempfreq = mtof(CENTERPITCHMIDI[i]);
    CENTERPITCHFREQS.push(tempfreq);
  }
  var pitchPoles = [];
  var pitchPolePitchIx = 0;
  var oscillators = [];
  var audioCtx;
  var gainNodes = [];
  var played = false;
  var startButton;
  var ppLinesIx = 0;
  var oscLinesIx = 0;
  // SET UP ----------------------------------------------------------- //
  function setup() {
    // Make a start button of the entire screen
    mkStartBtn();
    // Resize Window Action
    window.addEventListener('resize', winResize, false);
  }
  //FUNCTION mkStartBtn -------------------------------------------------- //
  function mkStartBtn() {
    startButton = document.createElement('button');
    startButton.style.backgroundColor = "transparent";
    // startButton.style.backgroundColor = "blue";
    startButton.style.positon = "absolute";
    startButton.style.width = '99vw';
    startButton.style.height = "99vh";
    startButton.style.top = "0px";
    startButton.style.left = "0px";
    startButton.addEventListener("click", play);
    document.body.appendChild(startButton);
  }
  //FUNCTION mkAddPPbtn -------------------------------------------------- //
  function mkAddPPbtn() {
    var ppDiv = document.createElement('div');
    ppDiv.id = "ppdiv";
    ppDiv.style.backgroundColor = "transparent";
    ppDiv.style.position = "absolute";
    ppDiv.style.bottom = "0px";
    ppDiv.style.left = "0px";
    ppDiv.style.height = "200px";
    ppDiv.style.width = "200px";
    document.body.appendChild(ppDiv);
    var addPPbtn = document.createElement('button');
    addPPbtn.style.backgroundColor = "transparent";
    addPPbtn.style.width = "100%";
    addPPbtn.style.height = "100%";
    addPPbtn.style.outline = "none";
    addPPbtn.style.positon = "absolute";
    addPPbtn.style.top = "0px";
    addPPbtn.style.left = "0px";
    addPPbtn.addEventListener("click", mkPitchPole);
    var blDiv = document.getElementById('ppdiv')
    blDiv.appendChild(addPPbtn);
  }
  //FUNCTION mkAddOscBtn -------------------------------------------------- //
  function mkAddOscBtn() {
    var obDiv = document.createElement('div');
    obDiv.id = "obdiv";
    obDiv.style.backgroundColor = "transparent";
    obDiv.style.position = "absolute";
    obDiv.style.bottom = "0px";
    obDiv.style.right = "0px";
    obDiv.style.height = "200px";
    obDiv.style.width = "200px";
    document.body.appendChild(obDiv);
    var addOscBtn = document.createElement('button');
    addOscBtn.style.backgroundColor = "transparent";
    addOscBtn.style.width = "100%";
    addOscBtn.style.height = "100%";
    addOscBtn.style.outline = "none";
    addOscBtn.style.positon = "absolute";
    addOscBtn.style.top = "0px";
    addOscBtn.style.left = "0px";
    addOscBtn.addEventListener("click", mkOscillatorLine);
    var brDiv = document.getElementById('obdiv')
    brDiv.appendChild(addOscBtn);
  }
  //FUNCTION mkPitchPole -------------------------------------------------- //
  function mkPitchPole() {
    // Make Gain Node ///////////////////////////////////
    var tempGainNode = audioCtx.createGain();
    tempGainNode.gain.setValueAtTime(0, audioCtx.currentTime);
    tempGainNode.connect(audioCtx.destination);
    // Make Oscillator ///////////////////////////////////
    var tempOsc = audioCtx.createOscillator();
    tempOsc.type = 'sine';
    var tempFreq = CENTERPITCHFREQS[pitchPolePitchIx];
    var tempMidi = CENTERPITCHMIDI[pitchPolePitchIx];
    var tClr = filterClrs[pitchPolePitchIx];
    var tppclr = ppClrs[pitchPolePitchIx];
    tempOsc.frequency.setValueAtTime(tempFreq, audioCtx.currentTime);
    pitchPolePitchIx = (pitchPolePitchIx + 1) % CENTERPITCHFREQS.length;
    tempOsc.connect(tempGainNode);
    tempOsc.start();
    var tempLine = mkPPLine(tClr, tppclr, ppLinesIx);
    var tppLineix = ppLinesIx;
    ppLinesIx++;
    var tNewGain = -24 + -90 + equalLoudnessCalc(tempFreq, 90);
    tNewGain = db2linamp(tNewGain);
    envAtk0(tempGainNode.gain, 6, tNewGain);
    //Make oscillator without line for every new pitchpole
    var tNewOscs = [];
    for (var i = 0; i < oscLinesSet.length; i++) {
      var tempGainNode2 = audioCtx.createGain();
      tempGainNode2.gain.setValueAtTime(0, audioCtx.currentTime);
      tempGainNode2.connect(audioCtx.destination);
      var tempOsc2 = audioCtx.createOscillator();
      tempOsc2.type = 'sine';
      tempOsc2.frequency.setValueAtTime(tempFreq, audioCtx.currentTime);
      tempOsc2.connect(tempGainNode2);
      tempOsc2.start();
      envAtk0(tempGainNode2.gain, 6, tNewGain);
      // var tempLineGroup = [templine, tempSpd, tempAccel, 1, ix];
      // var oscGr = [tempLine, tempGainNode, tempOsc, tGain, linesIx];
      // var ppGr = [tempLine, tempGainNode, tNewGain, tempOsc, tempFreq, tempMidi, tNewOscs, linesIx];
      var oscGr = [oscLinesSet[i], tempGainNode2, tempOsc2, tNewGain, oscLinesSet[i][4]];
      oscillators.push(oscGr);
      tNewOscs.push(oscGr);
    }
    var ppGr = [tempLine, tempGainNode, tNewGain, tempOsc, tempFreq, tempMidi, tNewOscs, tppLineix];
    pitchPoles.push(ppGr);
  }
  //FUNCTION initAudio ------------------------------------------------------ //
  function initAudio() {
    audioCtx = new(window.AudioContext || window.webkitAudioContext)();
  }
  //FUNCTION play ------------------------------------------------------ //
  function play() {
    if (!played) {
      played = true;
      startButton.parentNode.removeChild(startButton);
      mkAddPPbtn();
      mkAddOscBtn();
      initAudio();
      requestAnimationFrame(animationEngine);
    }
  }
  //FUNCTION mkOscillatorLine ------------------------------------------------- //
  function mkOscillatorLine() {
    var tosclineix = oscLinesIx;
    oscLinesIx++;
    var tempLine = mkOscLine(filterWhite, white, tosclineix);
    for (var i = 0; i < pitchPoles.length; i++) {
      // Make Gain Node ///////////////////////////////////
      var tempGainNode = audioCtx.createGain();
      tempGainNode.gain.setValueAtTime(0, audioCtx.currentTime);
      tempGainNode.connect(audioCtx.destination);
      // Make Oscillator ///////////////////////////////////
      var tempOsc = audioCtx.createOscillator();
      tempOsc.type = 'sine';
      tempOsc.frequency.setValueAtTime(440, audioCtx.currentTime);
      tempOsc.connect(tempGainNode);
      tempOsc.start();
      var tGain = pitchPoles[i][2];
      envAtk0(tempGainNode.gain, 6, tGain);
      var oscGr = [tempLine, tempGainNode, tempOsc, tGain, tosclineix];
      oscillators.push(oscGr);
      pitchPoles[i][6].push(oscGr);
    }
  }
  // FUNCTION mkPPLine ------------------------------------------------- //
  function mkPPLine(filterclr, lineclr, ix) {
    var templine = document.createElementNS(svgNS, 'line');
    templine.setAttributeNS(null, 'x1', 1);
    templine.setAttributeNS(null, 'x2', 1);
    templine.setAttributeNS(null, 'y1', 3);
    templine.setAttributeNS(null, 'y2', canvasH - 4);
    templine.setAttributeNS(null, 'stroke', lineclr);
    templine.setAttributeNS(null, 'stroke-width', 7);
    templine.setAttributeNS(null, 'filter', filterclr);
    templine.setAttributeNS(null, 'stroke-linecap', 'round');
    svgcanvas.appendChild(templine);
    var tempSpd = rrand(minSpd, maxSpd);
    var tempAccel = rrand(accelMin, accelMax);
    var tempLineGroup = [templine, tempSpd, tempAccel, 1, ix];
    ppLinesSet.push(tempLineGroup);
    return tempLineGroup;
  }
  // FUNCTION mkOscLine ------------------------------------------------- //
  function mkOscLine(filterclr, lineclr, ix) {
    var templine = document.createElementNS(svgNS, 'line');
    templine.setAttributeNS(null, 'x1', 1);
    templine.setAttributeNS(null, 'x2', 1);
    templine.setAttributeNS(null, 'y1', 3);
    templine.setAttributeNS(null, 'y2', canvasH - 4);
    templine.setAttributeNS(null, 'stroke', lineclr);
    templine.setAttributeNS(null, 'stroke-width', 7);
    templine.setAttributeNS(null, 'filter', filterclr);
    templine.setAttributeNS(null, 'stroke-linecap', 'round');
    svgcanvas.appendChild(templine);
    var tempSpd = rrand(minSpd, maxSpd);
    var tempAccel = rrand(accelMin, accelMax);
    var tempLineGroup = [templine, tempSpd, tempAccel, 1, ix];
    oscLinesSet.push(tempLineGroup);
    return tempLineGroup;
  }
  // ANIMATION ENGINE ----------------------------------------------- //
  function animationEngine(timestamp) {
    delta += timestamp - lastFrameTimeMs;
    lastFrameTimeMs = timestamp;
    while (delta >= MSPERFRAME) {
      update(MSPERFRAME);
      delta -= MSPERFRAME;
    }
    requestAnimationFrame(animationEngine);
  }
  // UPDATE ---------------------------------------------------------- //
  function update(MSPERFRAME) {
    // Clocks ////////////////////////////////////////////////
    framect++;
    pieceClock += MSPERFRAME;
    pieceClock = pieceClock - clockadj;
    // Lines /////////////////////////////////////////////////
    for (var i = 0; i < ppLinesSet.length; i++) {
      var oldX = parseFloat(ppLinesSet[i][0].getAttributeNS(null, 'x1'));
      var oldSpd = ppLinesSet[i][1];
      var oldAcc = ppLinesSet[i][2];
      var oldDir = ppLinesSet[i][3];
      var newSpd, newAcc, newDir, newX;
      var chgSpd;
      //// Boundry Detection ////////////////////////
      if (oldX > canvasW) {
        newDir = -1;
      } else if (oldX < 0) {
        newDir = 1;
      } else {
        newDir = oldDir;
      }
      //// Has Accel/Decel made the line too fast/slow?
      if (oldSpd > maxSpd || oldSpd < minSpd) {
        newAcc = scale((1 - norm(oldAcc, accelMin, accelMax)), 0.0, 1.0, accelMin, accelMax);
        if (oldSpd >= maxSpd) {
          chgSpd = maxSpd;
        } else if (oldSpd <= minSpd) {
          chgSpd = minSpd;
        }
        spdChgGate = false;
      } else {
        newAcc = oldAcc;
      }
      if (spdChgGate) {
        newSpd = oldSpd * newAcc;
      } else {
        newSpd = chgSpd * newAcc;
        spdChgGate = true;
      }
      newX = oldX + (newSpd * newDir);
      ppLinesSet[i][0].setAttributeNS(null, "x1", newX);
      ppLinesSet[i][0].setAttributeNS(null, "x2", newX);
      ppLinesSet[i][1] = newSpd;
      ppLinesSet[i][2] = newAcc;
      ppLinesSet[i][3] = newDir;
    }
    for (var i = 0; i < oscLinesSet.length; i++) {
      var oldX = parseFloat(oscLinesSet[i][0].getAttributeNS(null, 'x1'));
      var oldSpd = oscLinesSet[i][1];
      var oldAcc = oscLinesSet[i][2];
      var oldDir = oscLinesSet[i][3];
      var newSpd, newAcc, newDir, newX;
      var chgSpd;
      //// Boundry Detection ////////////////////////
      if (oldX > canvasW) {
        newDir = -1;
      } else if (oldX < 0) {
        newDir = 1;
      } else {
        newDir = oldDir;
      }
      //// Has Accel/Decel made the line too fast/slow?
      if (oldSpd > maxSpd || oldSpd < minSpd) {
        newAcc = scale((1 - norm(oldAcc, accelMin, accelMax)), 0.0, 1.0, accelMin, accelMax);
        if (oldSpd >= maxSpd) {
          chgSpd = maxSpd;
        } else if (oldSpd <= minSpd) {
          chgSpd = minSpd;
        }
        spdChgGate = false;
      } else {
        newAcc = oldAcc;
      }
      if (spdChgGate) {
        newSpd = oldSpd * newAcc;
      } else {
        newSpd = chgSpd * newAcc;
        spdChgGate = true;
      }
      newX = oldX + (newSpd * newDir);
      oscLinesSet[i][0].setAttributeNS(null, "x1", newX);
      oscLinesSet[i][0].setAttributeNS(null, "x2", newX);
      oscLinesSet[i][1] = newSpd;
      oscLinesSet[i][2] = newAcc;
      oscLinesSet[i][3] = newDir;
    }
    // OSCILLATORS ////////////////////////////////////////////
    for (var i = 0; i < oscLinesSet.length; i++) {
      var tOscX = parseFloat(oscLinesSet[i][0].getAttributeNS(null, 'x1'));
      for (var j = 0; j < ppLinesSet.length; j++) {
        var tPPx = parseFloat(ppLinesSet[j][0].getAttributeNS(null, "x1"));
        // Find distance between pitchpoleLine and oscillatorLine
        // & normalized midi difference
        var tDist = tPPx - tOscX;
        var tDiffMidi = scale(tDist, 0, canvasW, 0, 1);
        // Find pitchpole that corresponds to this ppline
        var tpp;
        for (var j2 = 0; j2 < pitchPoles.length; j2++) {
          if (pitchPoles[j2][7] == ppLinesSet[j][4]) {
            tpp = pitchPoles[j2];
            break;
          }
        }
        //for each pp look through the array of oscillators
        //and find the one that corresponds to this oscline
        var tbosc;
        for (var k = 0; k < tpp[6].length; k++) {
          if (tpp[6][k][4] == oscLinesSet[i][4]) { //linesix
            tbosc = tpp[6][k]; //oscgroup
            break;
          }
        }
        // Get Midi Pitch of pitch pole ///////////////////////////////////
        var tPPmidi = tpp[5];
        // Calculate a new frequency for the bosc
        var tNewFreq;
        if (tPPx >= tOscX) {
          tNewFreq = mtof(tPPmidi - tDiffMidi);
        } else if (tOscX > tPPx) {
          tNewFreq = mtof(tPPmidi + tDiffMidi);
        }
        if (framect % 240 == 0) {
          // console.log("pp " + j + ": " + ftom(tNewFreq));
        }
        tbosc[2].frequency.setValueAtTime(tNewFreq, audioCtx.currentTime);
      }
    }

  }

  //FUNCTION envAtk0 ------------------------------------------------------ //
  function envAtk0(vcaGain, attackDur, attackAmp) {
    var tblsz = 3000 * attackDur;
    var amptable = [];
    var attackAmpdb = linamp2db(attackAmp);
    var inc = Math.abs((-80 - attackAmpdb) / tblsz);
    for (var i = 0; i < tblsz; i++) {
      var tempamp = db2linamp(-80 + (inc * i));
      amptable.push(tempamp);
    }
    var now = audioCtx.currentTime;
    vcaGain.cancelScheduledValues(0);
    vcaGain.setValueAtTime(0, now);
    vcaGain.setValueCurveAtTime(amptable, now, attackDur);
    // vcaGain.linearRampToValueAtTime(attackAmp, attackDur);
  }
  //FUNCTION envAtk1 ------------------------------------------------------ //
  function envAtk1(vcaGain, attackStartTime, attackDur, attackAmp) {
    var tblsz = 3000 * attackDur;
    var amptable = [];
    var attackAmpdb = linamp2db(attackAmp);
    var iAmpDb;
    if (vcaGain.value != 0) {
      iAmpDb = linamp2db(vcaGain.value);
    } else {
      iAmpDb = -80;
    }
    var inc;
    if (attackAmpdb > iAmpDb) {
      inc = Math.abs(Math.abs(attackAmpdb) - Math.abs(iAmpDb)) / tblsz;
    } else if (iAmpDb > attackAmpdb) {
      inc = -1 * (Math.abs(Math.abs(iAmpDb) - Math.abs(attackAmpdb)) / tblsz);
    }
    for (var i = 0; i < tblsz; i++) {
      var tempamp = db2linamp(iAmpDb + (inc * i));
      amptable.push(tempamp);
    }
    var tStartTime = audioCtx.currentTime + attackStartTime;
    vcaGain.cancelScheduledValues(0);
    vcaGain.setValueCurveAtTime(amptable, tStartTime, attackDur);
    // vcaGain.linearRampToValueAtTime(attackAmp, attackDur);
  }
  //FUNCTION envOff ------------------------------------------------------ //
  function envOff(vcaGain, releaseTime) {
    var now = audioCtx.currentTime;
    vcaGain.cancelScheduledValues(0);
    vcaGain.setValueAtTime(vcaGain.value, now);
    vcaGain.linearRampToValueAtTime(0, now + releaseTime);
  }
  // FUNCTION: winResize ---------------------------------------------- //
  function winResize() {
    canvasW = window.innerWidth;
    canvasH = window.innerHeight;
    for (var i = 0; i < oscLinesSet.length; i++) {
      oscLinesSet[i][0].setAttributeNS(null, 'y2', canvasH - 4);
    }
    for (var i = 0; i < ppLinesSet.length; i++) {
      ppLinesSet[i][0].setAttributeNS(null, 'y2', canvasH - 4);
    }
  }
  // FUNCTION: mtof ---------------------------------------------- //
  function mtof(midinote) {
    var freq;
    freq = Math.pow(2, ((midinote - 69) / 12)) * 440;
    return freq;
  }
  // FUNCTION: ftom ---------------------------------------------- //
  function ftom(freq) {
    var midi;
    midi = (Math.log2((freq / 440)) * 12) + 69;
    return midi;
  }
  // FUNCTION: rrand ---------------------------------------------- //
  function rrand(min, max) {
    return Math.random() * (max - min) + min;
  }
  // FUNCTION: rrandInt ---------------------------------------------- //
  function rrandInt(min, max) {
    return Math.floor(Math.random() * (max - min) + min);
  }
  // FUNCTION: rrand ---------------------------------------------- //
  function choose(tempSet) {
    var randpick = rrandInt(0, tempSet.length);
    return tempSet[randpick];
  }
  // FUNCTION: scale ---------------------------------------------- //
  const scale = (num, in_min, in_max, out_min, out_max) => {
    return (num - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  }
  // FUNCTION: norm ---------------------------------------------- //
  const norm = (num, in_min, in_max) => {
    return (num - in_min) * (1.0 - 0.0) / (in_max - in_min);
  }
  // FUNCTION: shuffle ---------------------------------------------- //
  function shuffle(array) {
    for (let i = array.length - 1; i > 0; i--) {
      let j = Math.floor(Math.random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
  }
  // FUNCTION: db2linamp ---------------------------------------------- //
  function db2linamp(db) {
    var lamp = Math.pow(10, (db / 20));
    return lamp;
  }
  // FUNCTION: linamp2db ---------------------------------------------- //
  function linamp2db(linamp) {
    var db = 20 * Math.log(linamp);
    return db;
  }
  // FUNCTION: dbA ---------------------------------------------- //
  function equalLoudnessCalc(freq, phon) {
    var spl0, spl1, ix0, ix1, tAf0, tAf1;
    var f = [20, 25, 31.5, 40, 50, 63, 80, 100, 125, 160, 200, 250, 315, 400, 500, 630, 800,
      1000, 1250, 1600, 2000, 2500, 3150, 4000, 5000, 6300, 8000, 10000, 12500
    ];

    var af = [0.532, 0.506, 0.480, 0.455, 0.432, 0.409, 0.387, 0.367, 0.349, 0.330, 0.315,
      0.301, 0.288, 0.276, 0.267, 0.259, 0.253, 0.250, 0.246, 0.244, 0.243, 0.243,
      0.243, 0.242, 0.242, 0.245, 0.254, 0.271, 0.301
    ];

    var Lu = [-31.6, -27.2, -23.0, -19.1, -15.9, -13.0, -10.3, -8.1, -6.2, -4.5, -3.1,
      -2.0, -1.1, -0.4, 0.0, 0.3, 0.5, 0.0, -2.7, -4.1, -1.0, 1.7,
      2.5, 1.2, -2.1, -7.1, -11.2, -10.7, -3.1
    ];

    var Tf = [78.5, 68.7, 59.5, 51.1, 44.0, 37.5, 31.5, 26.5, 22.1, 17.9, 14.4,
      11.4, 8.6, 6.2, 4.4, 3.0, 2.2, 2.4, 3.5, 1.7, -1.3, -4.2,
      -6.0, -5.4, -1.5, 6.0, 12.6, 13.9, 12.3
    ];

    if ((phon < 0) || (phon > 90)) {
      spl = 0;
    } else {
      //find nearest frequencies in table
      for (var i = 0; i < f.length; i++) {
        if (freq < f[i]) {
          ix0 = i - 1;
          ix1 = i;
          break;
        }
      }
      //Deriving sound pressure level from loudness level (iso226 sect 4.1)
      tAf0 = (0.00447 * (Math.pow(10, (0.025 * phon)) - 1.15)) +
        Math.pow((0.4 * Math.pow(10, (((Tf[ix0] + Lu[ix0]) / 10) - 9))), af[ix0]);
      tAf1 = (0.00447 * (Math.pow(10, (0.025 * phon)) - 1.15)) +
        Math.pow((0.4 * Math.pow(10, (((Tf[ix1] + Lu[ix1]) / 10) - 9))), af[ix1]);
      spl0 = ((10 / af[ix0]) * Math.log10(tAf0)) - Lu[ix0] + 94;
      spl1 = ((10 / af[ix1]) * Math.log10(tAf1)) - Lu[ix1] + 94;
      // Return user data
      // spl = Lp;
      // freq = f;
    }
    spl = scale(ftom(freq), ftom(f[ix0]), ftom(f[ix1]), spl0, spl1);
    return spl;


  }
</script>

</html>
